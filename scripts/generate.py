#!/usr/bin/env python

"""
Generate fortran sources
"""

import os
import sys
import glob
import inspect
import re
import json
import logging

try:
    import mako
except ImportError:
    msg = """
Part of the sourcecode of XBeach is autogenerated.
This generation process uses the python package mako.
The mako python package was not found.
You can install mako package by the following command in a terminal/dos box:

pip install mako
"""
    print(msg)
    raise
import mako.template
import mako.lookup

logger = logging.getLogger(__name__)
logging.basicConfig()
logger.setLevel(logging.DEBUG)
def main():
    try:
        curfile = os.path.abspath(__file__)
    except NameError:
        curfile = os.path.abspath(inspect.getsourcefile(lambda : None))
    srcdir = os.path.join(os.path.dirname(curfile), '..', 'src', 'xbeachlibrary')
    templatedir = os.path.join(srcdir, "templates")
    variables_file = os.path.join(srcdir, 'variables.def')
    parameter_file = os.path.join(srcdir, 'params.def')

    # metacharacters are: . ^ $ * + ? { } [ ] \ | ( )
    variable_re = re.compile(r'''
    (
        (?P<commentline>(
            \s*!.*$ |
            \s*$
            )
        ) 
    )|
    (
    \s*                                            # start of the line
        (?P<fortrantype>(
            character              |
            logical                |
            double\ precision      |
            integer((\*4)?)        |
            real((\*4)|(\*8)?)     |
            complex((\*8)|(\*16)?) |
            double\ complex
            )
        )                                          # type
        (?P<len>(\(\w+\))?)                        # eg: (slen)
        .*                                         # anything
        target                                     # the word target
        .*                                         # anything
        ::                                         # double colon
        \s*                                        # possible spaces
        (?P<name>\w[\w\d]*)                        # the variable name
        (?P<dimension>(\([:,\w]+\))?)              # dimension
        .*                                         # anything
        !<?\s*                                     # comment
        (\((?P<altname>[\w/\d-]+)\))?              # alternative name
        \s*                                        # space
        \[(?P<unit>[\w/\d\-\._]+)\]                # unit
        \s*                                        # space
        (?P<description>.*?)                       # description
        \s*                                        # space
        ((?P<json>\{.*\}))?                        # JSON key-value pairs
        \s*                                        # space
        $                                          # end of line
    )
    ''',
    re.VERBOSE)

    # metacharacters are: . ^ $ * + ? { } [ ] \ | ( )
    # inside [ ]:         - ^ \
    parameter_re = re.compile(r'''
    (
        (?P<commentline>(
            \s*!.*$ |
            \s*$
            )
        ) 
    )|
    (
        \s*                                       # start of the line
        (?P<fortrantype>(
            character              |
            logical                |
            double\ precision      |
            integer((\*4)?)        |
            real((\*4)|(\*8)?)     |
            complex((\*8)|(\*16)?) |
            double\ complex
            )
        )                                         # type
        (?P<len>(\(\w+\))?)                       # eg: (slen)
        \s*                                       # possible spaces
        (?P<extratype>(,\s*\w+)?)                 # e.g.: , allocatable
        \s*                                       # possible spaces
        ::                                        # double colon
        \s*                                       # possible spaces
        (?P<name>\w[\w]*)                         # the variable name
        \s*                                       # possible spaces
        (?P<dimension>(\([:,\w]+\))?)             # dimension
        \s*                                       # possible spaces
        (?P<value>(=\s*[^\s]+)?)                  # value
        .*                                        # anything
        (!<?\s*)?                                 # comment
        (\[(?P<unit>[\^\w\-\._]+)\])?             # unit
        \s*                                       # space
        (?P<description>.*?)                      # description
        \s*                                       # space
        ((?P<json>\{.*\}))?                       # JSON key-value pairs
        \s*                                       # space
        $                                         # end of line
    )
    ''',
    re.VERBOSE)

    FORTRANTYPESMAP = {
        'character'         : 'char',
        'complex'           : 'complex',
        'complex*16'        : 'double complex',
        'complex*8'         : 'complex',
        'double complex'    : 'double complex',
        'double precision'  : 'double',
        'integer'           : 'int',
        'integer*4'         : 'int',
        'logical'           : 'bool',
        'real'              : 'float',
        'real*4'            : 'float',
        'real*8'            : 'double',
    }

    variables = []
    lineno = 0
    with open(variables_file) as f:
        for line in f.readlines():
            lineno += 1
            match = variable_re.match(line)
            try:
                if match:
                    variable = match.groupdict()
                    if not variable['commentline']:
                        if variable['dimension'].strip():
                            variable['rank'] = variable['dimension'].count(',') + 1
                        else:
                            variable['rank'] = 0
                        variable['type'] = FORTRANTYPESMAP[variable['fortrantype']]
                        if "json" in variable and variable["json"]:
                            variable.update(json.loads(variable["json"]))
                        variables.append(variable)
                else:
                    raise RuntimeError('Something wrong while parsing variables')
            except Exception as e:
                print (e)
                print ("Error while parsing line "+str(lineno)+" in "+variables_file+":")
                print (line)
                sys.exit(1)

    parameters = []
    lineno = 0
    with open(parameter_file) as f:
        for line in f.readlines():
            lineno += 1
            match = parameter_re.match(line)
            try:
                if match:
                    parameter = match.groupdict()
                    if not parameter['commentline']:
                        if parameter['dimension'].strip():
                            parameter['rank'] = parameter['dimension'].count(',') + 1
                        else:
                            parameter['rank'] = 0
                        parameter['type'] = FORTRANTYPESMAP[parameter['fortrantype']]
                        if "json" in parameter and parameter["json"]:
                            parameter.update(json.loads(parameter["json"]))
                        parameters.append(parameter)
                else:
                    raise RuntimeError('Something wrong while parsing parameters')
            except Exception as e:
                print (e)
                print ("Error while parsing line "+str(lineno)+" in "+parameter_file+":")
                print (line)
                sys.exit(1)

    ISOTYPESMAP = {
        'bool'           : 'logical(c_bool)',
        'char'           : 'character(kind=c_char)',
        'complex'        : 'complex(c_float_complex)',
        'double complex' : 'complex(c_double_complex)',
        'double'         : 'real(c_double)',
        'float'          : 'real(c_float)',
        'int'            : 'integer(c_int)'
    }


    def dimstr(shape):
        shapetxt = ",".join(str(x) for x in shape)
        if shapetxt:
            return "(" + shapetxt + ")"
        else:
            return ""
    # if parameters are given, we expect these to be like "x.mako"
    # the file from the templates directory will
    # be converted to "x.inc"
    if (len(sys.argv) > 1):
        templates = []
        for i in range(1,len(sys.argv)):
            templates.append(os.path.basename(sys.argv[i]))
    else:
        # not documented function in glob
        templates = glob.glob1(templatedir, '*.mako')

    # lookup = mako.lookup.TemplateLookup(directories=[templatedir], module_directory='/tmp/mako_modules')
    # wwvv: do not use module_directory: this clashes when compiling different versions of xbeach
    lookup = mako.lookup.TemplateLookup(directories=[templatedir])

    #logger.info("parsing templates in %s", templatedir)
    if (os.name == "nt"):  # are we running on widows?
        newline="\n"       # then \n will be output as \r\n
    else:
        newline = "\r\n"   # in unix, we also want \r\n for newline

    for template_name in templates:
        template = lookup.get_template(template_name)
        filename = template_name.replace('.mako', '.inc')
        logger.info("MAKO: %s -> %s", template_name, filename)
        with open(os.path.join(srcdir, filename), 'w') as f:
            f.write("! This file is generated by 'scripts/generate.py' using"+newline)
            f.write("!    /src/xbeachlibrary/"+os.path.basename(variables_file)+newline)
            f.write("!    /src/xbeachlibrary/"+os.path.basename(parameter_file)+newline)
            f.write("!    src/xbeachlibray/templates/"+template_name+newline)
            f.write("! Advice: do not edit this file, but above mentioned files."+newline)
            f.write(newline);
            rendered = template.render(**locals())
            f.write(rendered)
            f.write(newline);
            f.write("! vim: filetype=fortran"+newline)

    jsondata = {
        "comment": "do not edit this file, it is autogenerated by generate.py",
        "variables": variables
    }
    if (False):
        json.dump(jsondata, open('extractedvariables.json', 'w'), indent=4)
if __name__ == "__main__":
    main()
